
В целом подход правильный. Проделана хорошая работа, которую нужно немного довести до ума. 

1) Нужно вынести всю логику, связанную с gridGroup, в отдельный файл. За образец такого выноса можно взять, например, /client/src/lib/three/CurvesLine.js . Это обьект для ребер модели в проекта, которые по надатию кнопки могут просвечивать - он состоит из двух LineSegments. У тебя, видимо, gridGroup будет состоять из множества Line , которые будут динамически возникать и убираться.

2) Хочется сделать эту работу функционально богаче. Сейчас у нас есть сетка зеленых линий размера 1, сетка желтых линий размера 1 смещенная и сетка красных линий размера четверть. Если я бесконечно приближаю, или бесконечно удаляю, в какой то момент у меня перестают появляться новые размерные линии. Разумеется, можно сделать "красные" линии более частыми, но это не решит дело а лишь добавит мешанину красных линий. Можно добавить новых типов линий, но это так же не решит дело.

Попробуй сделать так.

Пусть у тебя будут линии размера 4, линии размера 3, линии размера 2 и линии размера 1. Под размером я имею ввиду их толщину на экране в пикселях. 

Сделай так, что бы вне зависимости от того, как пользователь приближал и удалял модельку, у него на экране будет наличествовать следующий набор вертикальных линий

1) Одна линия размера 4, проходящая через центр модели и символизирующая ось координат
2) Две или четыре линии размера 3, одна или две из которых находится в области примерно в области от левого края экрана до трети ширины экрана, а остальные - заркально им, от двух/третей до правого края. 
3) Между линиями размеров 3 и 4, посередине каждого интервала - линии размеров 2
4) Между линиями размеров 2, 3, 4, в каждом интервале, отсекаемом ими - по 4 линии размера 1.

При этом любые расстояния между линиями должны описываться целыми числами.

Пример. Допустим, розовый кубик имеет сторону 1 см. Я приблизил розовый кубик так, как показано на скриншоте. Представь на месте зеленых линий линии размера 4 и 3. Те зеленые линии, которые проходят через центр кубика, имееют размер 4, оставшиеся - размер 3. При этом мы видим 4 вертикальных и 2 горизонтальных линии размера 3, расстояние между двумя линиями размера 3 или линией размера 3 и линией размера 4 всегда ровно один сантиметр.

Красные линии символизируют размер 2. Между любыми двумя линиями размеров 3 и 4 есть по центру линия красного цвета. С ними расстояние между ближними линиями составляет полсантиметра. Я не стал кодировать в твоей программе линии размеров 1, пусть это сделает твое воображение. С линиями размера один расстояние между любыми двумя линиями составит миллиметр.

Теперь мы приближаем модель. В какой-то момент горизонтальные зеленые линии исчезают за экраном. В этот момент сетка должна ремасштабироваться. Теперь все линии, которые сейчас видны на скриншоте, должны быть линиями размера 3 или 4. Между ними должны возникнуть линии размера 2 (которых сейчас нет) и линии размера 1. Теперь расстояние между двумя линиями размера 1 составляет полмиллиметра.

Сделай так, что бы расстояние между линиями размеров 1 (и вообще ближайщими линиями в сетке), т.е. самая маленькая размерная единица, которую показывает сетка, всегда принадлежала следующему ряду:

... 50 20 10 5 2 1 0.5 0.2 0.1 0.05 0.02 0.01 ...

Логика построения ряда, думаю, очевидна.

3) Сетка должна быть бесконечна в обе стороны. Если я приближаю модель до атомов (10^-9 - мне потребуется крутить колесиком мышки совсем недолго!) или наоборот хочу отдалиться от неё на световой год - даже если это не имеет никакого прикладного смысла в контексте нашей задачи, я хочу, что бы сетка всё равно продолжала показываться. Соответственно, её нужно сделать истинно адаптивной к текущему масштабу, постоянно уничтожающей и создающей линии в зависимости от текущей нужды.

4) Сетка должна быть настраиваемой, и представление должно быть отделено от конфигурации, а конфигурация - от логики. Если нам придет в голову после сделать линии размера 1 лазоревыми, а линии размера 4 сделать линиями размера 5, это должно быть возможно осуществить, просто скорректировав свойство материала одной линии. Если мы заходим добавить ещё один размер линий, что бы ещё сильнее размельчить, должно быть достаточно просто дописать одну или две строки кода о том, что требуется ещё одна линия с таким-то относительным расстоянием и таким-то материалом. 

5) Я хотел нарисовать в текущем коде из линий то, что описал выше словами, что бы проиллюстрировать, но не смог продраться через код, наподобие вот такого:             

if (zoom >=2) {
    gridGroup.children.forEach((child) => {
        if(child.material.color.getHex() === 0xFFFF00){
            gridGroup.remove(child);
        }
    });

Я не буду сейчас давать code review. Задача, поставленная выше, имеет определенную степень сложности, и эту степень нельзя преодалеть, вводя в код команды наподобие "удалить-все-желтые-линии". Когда ты придумаешь, как её решить, мы разберем новый код.